<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8" />
    <title>âœ… Ù…ØµÙ…Ù… Ø§Ù„ØºØ±Ù Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ - Ø¹ØµØ§Ù… Ø§Ù„ÙƒÙ‡Ø±Ø¨Ø§Ø¦ÙŠ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <script src="./three.min.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./GLTFExporter.js"></script>
    <script src="./GLTFLoader.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>

    
    <style>
        /* 1. ØªØµÙ…ÙŠÙ… Ø§Ù„Ø¬Ø³Ù… (Body) Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ */
        body { 
            margin: 0; font-family: system-ui, sans-serif; background: #f6f7fb; 
            display: flex; flex-direction: column; min-height: 100vh; 
            position: relative;
        }
        header { background: #1f2937; color: #fff; padding: 10px 14px; flex-shrink: 0; display: flex; justify-content: space-between; align-items: center; }
        header h2 { margin: 0; font-size: 18px; }
        
        /* 2. Ø´Ø±ÙŠØ· Ø§Ù„Ø£Ø¯ÙˆØ§Øª (Toolbar) Ø§Ù„Ù…Ø­Ø³Ù‘ÙÙ† */
        #toolbar { 
            display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-start; 
            padding: 8px; background: #eef0f4; border-bottom: 1px solid #dadde3;
            flex-shrink: 0;
            justify-content: flex-start;
        }
        
        /* 3. Ø­Ø§ÙˆÙŠØ§Øª Ø§Ù„ØªØ­ÙƒÙ… */
        .control-group { padding: 5px; border: 1px solid #dadde3; border-radius: 6px; background: #fff; display: flex; flex-direction: column; gap: 6px; width: 180px; }
        .control-group h4 { margin: 0; font-size: 13px; padding-bottom: 3px; border-bottom: 1px solid #eee; font-weight: 600; }

        .dim-input { display: flex; justify-content: space-between; align-items: center; font-size: 13px; }
        .dim-input input { width: 40px; padding: 3px; border: 1px solid #ccc; border-radius: 3px; }

        .file-row { display: flex; align-items: center; gap: 4px; justify-content: space-between; font-size: 12px; }
        .file-row label { flex-shrink: 0; width: 45px; }
        .file-upload-btn { flex-grow: 1; text-align: center; padding: 4px 6px; font-size: 12px; }

        .btn { padding: 6px 8px; border: 1px solid #cbd3df; border-radius: 6px; background: #fff; cursor: pointer; transition: background-color 0.2s; font-size: 13px; }
        .btn.primary { background: #2563eb; color: #fff; border-color: #2563eb; }
        .btn:disabled { opacity: .6; cursor: not-allowed; }
        
        .preview { border: 1px dashed #cbd3df; border-radius: 4px; height: 28px; width: 28px; display: flex; align-items: center; justify-content: center; overflow: hidden; background: #fafbff; flex-shrink: 0; }
        .preview small { font-size: 9px; }
        .preview img { max-width: 100%; max-height: 100%; display: block; object-fit: contain; }

        /* ğŸ’¡ Ø²Ø± Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…Ø¨Ø§Ø´Ø± */
        .color-picker-btn {
            background: none;
            border: 1px solid #ccc;
            width: 28px;
            height: 28px;
            padding: 0;
            border-radius: 4px;
            cursor: pointer;
            flex-shrink: 0;
            position: relative;
        }
        .color-picker-btn input[type="color"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        /* 4. Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø¹Ø±Ø¶ (Canvas) Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: ØªØ£Ø®Ø° Ø§Ù„Ø­ÙŠØ² Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ */
        canvas { display: block; width: 100%; flex-grow: 1; background: #cfd5e1; }

        /* ğŸ’¡ Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø¹Ù„ÙˆÙŠØ© (ÙÙˆÙ‚ Canvas) */
        #canvas-overlay-tools {
            position: absolute;
            top: 0;
            right: 0;
            padding: 10px;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        /* ğŸ’¡ Ø²Ø± Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© ÙˆØ´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© */
        #fullscreen-btn, #light-slider-btn {
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: none;
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
        }
        #light-slider-container {
            display: flex; 
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
        }
        #light-slider-container input {
            vertical-align: middle;
        }
        
        /* ğŸ’¡ ØªÙ†Ø³ÙŠÙ‚ ÙˆØ¶Ø¹ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© (Canvas) */
        .fullscreen-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 999;
        }

        /* 5. Ø£Ø¯Ø§Ø© Ø§Ù„Ù‚Øµ (Cropping Tool) */
        #crop-tool { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; justify-content: center; align-items: center; }
        #crop-tool-content { background: #fff; padding: 15px; border-radius: 10px; max-width: 95%; max-height: 95%; overflow: hidden; display: flex; flex-direction: column; }
        
        /* ğŸ’¡ ØªØ­ÙƒÙ…Ø§Øª Ø§Ù„Ù‚Øµ (Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©) */
        #crop-controls {
            flex-shrink: 0;
            padding: 10px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            align-items: center;
        }
        #crop-actions { display: flex; justify-content: center; gap: 10px; margin-top: 15px; flex-shrink: 0; }
        #crop-container { flex-grow: 1; overflow: auto; max-height: 70vh; margin-bottom: 10px; }
        #crop-image { max-width: 100%; display: block; }
        
        /* ğŸ’¡ Ø¯ÙˆØ±Ø§Ù† Ø¯Ù‚ÙŠÙ‚ */
        #rotate-controls { display: flex; gap: 5px; align-items: center; font-size: 13px; }
        #rotate-controls input[type="number"] { width: 40px; padding: 3px; border: 1px solid #ccc; border-radius: 3px; text-align: center; }
        #rotate-slider { width: 100px; }
    </style>
</head>
<body>

<header>
    <h2>âœ… Ù…ØµÙ…Ù… Ø§Ù„ØºØ±Ù Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯</h2>
</header>

<div id="toolbar">
    <div id="dim-controls" class="control-group">
        <h4>Ù…Ù‚Ø§Ø³Ø§Øª Ø§Ù„ØºØ±ÙØ©</h4>
        <div class="dim-input">
            <label for="room-length">Ø§Ù„Ø·ÙˆÙ„ (X):</label>
            <input type="number" id="room-length" value="5" min="1" step="0.1">
        </div>
        <div class="dim-input">
            <label for="room-width">Ø§Ù„Ø¹Ø±Ø¶ (Z):</label>
            <input type="number" id="room-width" value="5" min="1" step="0.1">
        </div>
        <div class="dim-input">
            <label for="room-height">Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Y):</label>
            <input type="number" id="room-height" value="3" min="1" step="0.1">
        </div>
        <button class="btn primary" id="update-room">Ø¥Ù†Ø´Ø§Ø¡/ØªØ­Ø¯ÙŠØ«</button>
    </div>

    <div id="wall-files" class="control-group">
        <h4>ØµÙˆØ± Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†</h4>
        <div class="file-row">
            <label>Ø£Ù…Ø§Ù…ÙŠ:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="front" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="front" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-front"><small>F</small></div>
        </div>
        <div class="file-row">
            <label>Ø®Ù„ÙÙŠ:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="back" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="back" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-back"><small>B</small></div>
        </div>
        <div class="file-row">
            <label>Ø£ÙŠØ³Ø±:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="left" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="left" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-left"><small>L</small></div>
        </div>
        <div class="file-row">
            <label>Ø£ÙŠÙ…Ù†:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="right" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="right" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-right"><small>R</small></div>
        </div>
    </div>
    
    <div id="floor-ceiling-files" class="control-group">
        <h4>Ø£Ø±Ø¶ÙŠØ© ÙˆØ³Ù‚Ù</h4>
        <div class="file-row">
            <label>Ø£Ø±Ø¶ÙŠØ©:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="floor" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="floor" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-floor"><small>FL</small></div>
        </div>
        <div class="file-row">
            <label>Ø³Ù‚Ù:</label>
            <label class="btn file-upload-btn"> Ø±ÙØ¹ <input type="file" data-wall="ceiling" accept="image/*" class="file-input" style="display:none"></label>
            <button class="color-picker-btn" data-wall="ceiling" title="Ù„ÙˆÙ† Ø«Ø§Ø¨Øª">
                ğŸ¨<input type="color" class="color-input">
            </button>
            <div class="preview" id="preview-ceiling"><small>C</small></div>
        </div>
    </div>
    
    <div id="action-controls" class="control-group">
        <h4>Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</h4>
        <button class="btn primary" id="exportGLB" disabled>ğŸ’¾ Ø­ÙØ¸ GLB</button>
        <label class="btn">
            ğŸ“‚ ØªØ­Ù…ÙŠÙ„ GLB
            <input type="file" id="importGLB" accept=".glb,.gltf" style="display:none">
        </label>
        <button class="btn" id="clear-saved">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª</button>
    </div>
</div>

<div style="position: relative; flex-grow: 1; width: 100%;">
    <canvas id="canvas3d"></canvas>
    
    <div id="canvas-overlay-tools">
        <div id="light-slider-container">
            <input type="range" id="light-intensity" min="0" max="3" step="0.1" value="0.8" title="Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©">
        </div>
        <button id="fullscreen-btn" title="Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©">â—»ï¸</button>
    </div>
</div>

<div id="crop-tool">
    <div id="crop-tool-content">
        <h3>Ø£Ø¯Ø§Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© (Ø§Ù„Ù‚Øµ ÙˆØ§Ù„Ø¯ÙˆØ±Ø§Ù†)</h3>
        
        <div id="crop-controls">
            <div id="rotate-controls" class="control-box">
                <span>Ø¯ÙˆØ±Ø§Ù† (Ø¨Ø§Ù„Ø¯Ø±Ø¬Ø©):</span>
                <input type="range" id="rotate-slider" min="-180" max="180" step="1" value="0">
                <input type="number" id="rotate-value" min="-360" max="360" step="1" value="0">
            </div>
            <div class="control-box">
                <span>Ø§Ù†Ø¹ÙƒØ§Ø³:</span>
                <div style="display: flex; gap: 5px;">
                    <button data-method="scaleX" data-option="-1" title="Ø§Ù†Ø¹ÙƒØ§Ø³ Ø£ÙÙ‚ÙŠ">â†”ï¸</button>
                    <button data-method="scaleY" data-option="-1" title="Ø§Ù†Ø¹ÙƒØ§Ø³ Ø¹Ù…ÙˆØ¯ÙŠ">â†•ï¸</button>
                </div>
            </div>
        </div>
        
        <div id="crop-container">
            <img id="crop-image" src="" alt="ØµÙˆØ±Ø© Ù„Ù„Ù‚Øµ">
        </div>
        <div id="crop-actions">
            <button class="btn primary" id="crop-apply">ØªØ·Ø¨ÙŠÙ‚ ÙˆÙ‚Øµ</button>
            <button class="btn" id="crop-cancel">Ø¥Ù„ØºØ§Ø¡</button>
        </div>
    </div>
</div>

<script>
// --- Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ø¹Ø§Ù…Ø© ---
let renderer, scene, camera, controls;
let sceneGroup = new THREE.Group(); 
const textureLoader = new THREE.TextureLoader(); 
let cropperInstance = null; 
let directionalLight = null; 
let ambientLight = null; 
let isFullscreen = false;   
let autoRotateTimeout = null; 

const ROOM_DATA = {
    length: 5, width: 5, height: 3, 
    textures: { front: null, back: null, left: null, right: null, floor: null, ceiling: null }
};

const DEFAULT_CEILING_COLOR = 0xFFFFFF; 
const DEFAULT_FLOOR_COLOR = 0x333333;   
const DEFAULT_WALL_COLOR = 0xcccccc;    
const CAMERA_HEIGHT = 1.6;              
let currentWallToCrop = null; 

// --- ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¹Ø§Ù…Ø© ---

function disposeThreeObjects(group) {
    if (!group) return;
    group.traverse(child => {
        if (child.isMesh) {
            child.geometry.dispose();
            if (Array.isArray(child.material)) {
                child.material.forEach(m => {
                    if (m.map) m.map.dispose();
                    m.dispose();
                });
            } else {
                if (child.material.map) child.material.map.dispose();
                child.material.dispose();
            }
        }
    });
}

function fileToBase64(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = error => reject(error);
        reader.readAsDataURL(file);
    });
}

// ğŸ’¡ ÙˆØ¸ÙŠÙØ© ØªØ­ÙˆÙŠÙ„ Ù„ÙˆÙ† Ø³Ø¯Ø§Ø³ÙŠ Ø¥Ù„Ù‰ Base64 Data URL
function colorToDataURL(hexColor) {
    // Ù†Ø³ØªØ®Ø¯Ù… Ù‚ÙŠÙ…Ø© HEX Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ ÙˆÙ‡ÙŠ Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„Ø­ÙØ¸ ÙÙŠ localStorage
    return hexColor; 
}

function saveStateToLocalStorage() {
    localStorage.setItem('room_config', JSON.stringify({
        dimensions: {
            length: ROOM_DATA.length,
            width: ROOM_DATA.width,
            height: ROOM_DATA.height
        },
        textures: ROOM_DATA.textures, // ÙŠØªÙ… ØªØ®Ø²ÙŠÙ† Base64 Ø£Ùˆ Ø§Ù„Ù„ÙˆÙ† HEX Ù‡Ù†Ø§
        lightIntensity: directionalLight ? directionalLight.intensity : 0.8,
        ambientIntensity: ambientLight ? ambientLight.intensity : 0.4,
        autoRotate: controls ? controls.autoRotate : false
    }));
    console.log('âœ… ØªÙ… Ø­ÙØ¸ Ø­Ø§Ù„Ø© Ø§Ù„ØºØ±ÙØ© ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­.');
}

function loadStateFromLocalStorage() {
    const savedData = localStorage.getItem('room_config');
    if (savedData) {
        const data = JSON.parse(savedData);
        ROOM_DATA.length = parseFloat(data.dimensions.length) || ROOM_DATA.length;
        ROOM_DATA.width = parseFloat(data.dimensions.width) || ROOM_DATA.width;
        ROOM_DATA.height = parseFloat(data.dimensions.height) || ROOM_DATA.height;
        
        document.getElementById('room-length').value = ROOM_DATA.length;
        document.getElementById('room-width').value = ROOM_DATA.width;
        document.getElementById('room-height').value = ROOM_DATA.height;

        if (data.textures) {
            Object.assign(ROOM_DATA.textures, data.textures);
            for (const wall in ROOM_DATA.textures) {
                const url = ROOM_DATA.textures[wall];
                const preview = document.getElementById(`preview-${wall}`);
                if (preview && url) {
                    // ğŸ’¡ Ø¥ØµÙ„Ø§Ø­ Ù…Ù†Ø·Ù‚ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©
                    if (url.startsWith('#')) {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ù„ÙˆÙ† Ø³Ø¯Ø§Ø³ÙŠ
                        preview.innerHTML = `<small style="background-color: ${url}; width: 100%; height: 100%; display: block;"></small>`;
                        const colorInput = document.querySelector(`.color-picker-btn[data-wall="${wall}"] .color-input`);
                        if(colorInput) colorInput.value = url;
                    } else if (url.startsWith('data:')) {
                        // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØµÙˆØ±Ø© Base64
                        preview.innerHTML = `<img src="${url}">`;
                    }
                }
            }
        }
        
        if (directionalLight) {
            directionalLight.intensity = data.lightIntensity || 0.8;
            document.getElementById('light-intensity').value = directionalLight.intensity;
        }
        if (ambientLight) {
            ambientLight.intensity = data.ambientIntensity || 0.4;
        }

        if (controls) {
            controls.autoRotate = data.autoRotate || true;
        }

        console.log('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø­Ø§Ù„Ø© Ø§Ù„ØºØ±ÙØ© Ù…Ù† Ø§Ù„Ù…ØªØµÙØ­.');
        return true;
    }
    return false;
}

// --- ÙˆØ¸Ø§Ø¦Ù Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ¹Ø±Ø¶ Ø§Ù„Ù…Ø´Ù‡Ø¯ ---

async function createTextureFromDataURL(url) {
    if (!url) return null;

    // ğŸ’¡ Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù‚ÙŠÙ…Ø© Ù„ÙˆÙ† Ø³Ø¯Ø§Ø³ÙŠØŒ Ù†Ù†Ø´Ø¦ Ù†Ø³ÙŠØ¬Ù‹Ø§ Ø¨Ù„ÙˆÙ† Ø«Ø§Ø¨Øª
    if (url.startsWith('#')) {
        const canvas = document.createElement('canvas');
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = url;
        ctx.fillRect(0, 0, 1, 1);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.encoding = THREE.sRGBEncoding;
        return texture;
    }

    return new Promise((resolve) => {
        textureLoader.load(url, 
            (texture) => {
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                texture.encoding = THREE.sRGBEncoding; 
                resolve(texture);
            },
            undefined, 
            () => resolve(null) 
        );
    });
}

function createWall(name, geo, material, position, rotation) {
    const mesh = new THREE.Mesh(geo, material);
    mesh.name = name;
    mesh.position.set(position.x, position.y, position.z);
    mesh.rotation.set(rotation.x, rotation.y, rotation.z);
    return mesh;
}

async function buildScene() {
    const L = parseFloat(ROOM_DATA.length);
    const W = parseFloat(ROOM_DATA.width);
    const H = parseFloat(ROOM_DATA.height);

    scene.remove(sceneGroup);
    disposeThreeObjects(sceneGroup);
    sceneGroup = new THREE.Group(); 
    
    const textures = {};
    for (const wall in ROOM_DATA.textures) {
        textures[wall] = await createTextureFromDataURL(ROOM_DATA.textures[wall]);
    }
    
    const walls = [
        { name: 'Front_Wall', geo: new THREE.PlaneGeometry(L, H), map: textures.front, pos: { x: 0, y: 0, z: -W / 2 }, rot: { x: 0, y: 0, z: 0 }, dim: [L, H] },
        { name: 'Back_Wall', geo: new THREE.PlaneGeometry(L, H), map: textures.back, pos: { x: 0, y: 0, z: W / 2 }, rot: { x: 0, y: Math.PI, z: 0 }, dim: [L, H] },
        { name: 'Right_Wall', geo: new THREE.PlaneGeometry(W, H), map: textures.right, pos: { x: L / 2, y: 0, z: 0 }, rot: { x: 0, y: -Math.PI / 2, z: 0 }, dim: [W, H] },
        { name: 'Left_Wall', geo: new THREE.PlaneGeometry(W, H), map: textures.left, pos: { x: -L / 2, y: 0, z: 0 }, rot: { x: 0, y: Math.PI / 2, z: 0 }, dim: [W, H] },
        { name: 'Floor', geo: new THREE.PlaneGeometry(L, W), map: textures.floor, pos: { x: 0, y: -H / 2, z: 0 }, rot: { x: -Math.PI / 2, y: 0, z: 0 }, dim: [L, W] },
        { name: 'Ceiling', geo: new THREE.PlaneGeometry(L, W), map: textures.ceiling, pos: { x: 0, y: H / 2, z: 0 }, rot: { x: Math.PI / 2, y: 0, z: 0 }, dim: [L, W] }
    ];

    walls.forEach(w => {
        let materialColor = DEFAULT_WALL_COLOR;
        if (w.name === 'Floor') materialColor = DEFAULT_FLOOR_COLOR;
        if (w.name === 'Ceiling') materialColor = DEFAULT_CEILING_COLOR;

        const materialColorBase = w.map ? 0xFFFFFF : materialColor;

        const material = new THREE.MeshStandardMaterial({ 
            map: w.map, 
            side: THREE.DoubleSide, 
            color: materialColorBase
        });

        if (w.map) {
            w.map.repeat.set(1, 1);
            w.map.offset.set(0, 0);
        }

        const mesh = createWall(w.name, w.geo, material, w.pos, w.rot);
        sceneGroup.add(mesh);
    });

    updateCameraPosition(L, W, H);
    scene.add(sceneGroup); 

    document.getElementById('exportGLB').disabled = false; 
    saveStateToLocalStorage();
}


function updateCameraPosition(L, W, H) {
    camera.position.set(0, CAMERA_HEIGHT - (H / 2), 0);
    controls.target.set(0, CAMERA_HEIGHT - (H / 2), 0);
    controls.update();

    const maxDim = Math.max(L, W, H);
    camera.far = maxDim * 4;
    camera.updateProjectionMatrix();

    controls.maxDistance = maxDim * 0.8; 
    controls.minDistance = 0.5; 
}

function initThree(){
    const headerHeight = document.querySelector('header').offsetHeight;
    const toolbarHeight = document.getElementById('toolbar').offsetHeight;
    const canvasHeight = window.innerHeight - headerHeight - toolbarHeight;

    renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas3d'), antialias:true});
    renderer.setSize(window.innerWidth, canvasHeight);
    renderer.outputEncoding = THREE.sRGBEncoding; 
    
    const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
    renderer.info.render.textureCount = maxAnisotropy; 

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xEEEEEE); 

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / canvasHeight, 0.1, 100);
    
    ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5).normalize();
    scene.add(directionalLight);

    controls = new THREE.OrbitControls(camera, renderer.domElement); 
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false; 
    
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.0; 

    controls.maxPolarAngle = Math.PI; 
    controls.minPolarAngle = 0; 
    
    controls.addEventListener('start', () => {
        controls.autoRotate = false;
        clearTimeout(autoRotateTimeout); 
    });
    
    controls.addEventListener('end', () => {
        autoRotateTimeout = setTimeout(() => {
            controls.autoRotate = true;
            saveStateToLocalStorage(); 
        }, 1500); 
    });

    window.addEventListener('resize', ()=>{
        updateRendererSize();
    });

    animate();
    loadStateFromLocalStorage(); 
}

function updateRendererSize() {
    const canvas = document.getElementById('canvas3d');
    const header = document.querySelector('header');
    const toolbar = document.getElementById('toolbar');
    
    if (isFullscreen) {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        header.style.display = 'none';
        toolbar.style.display = 'none';
    } else {
        const headerHeight = header.offsetHeight;
        const toolbarHeight = toolbar.offsetHeight;
        const canvasHeight = window.innerHeight - headerHeight - toolbarHeight;
        
        renderer.setSize(window.innerWidth, canvasHeight);
        camera.aspect = window.innerWidth / canvasHeight;
        header.style.display = 'flex';
        toolbar.style.display = 'flex';
    }
    camera.updateProjectionMatrix();
}

function animate(){
    requestAnimationFrame(animate);
    controls && controls.update();
    renderer.render(scene, camera);
}

function setupEventListeners() {
    // Ù…Ø¹Ø§Ù„Ø¬ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯
    document.getElementById('update-room').addEventListener('click', async ()=>{
        ROOM_DATA.length = document.getElementById('room-length').value;
        ROOM_DATA.width = document.getElementById('room-width').value;
        ROOM_DATA.height = document.getElementById('room-height').value;
        await buildScene();
    });

    // ğŸ’¡ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ÙˆÙ† Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
    document.querySelectorAll('.color-input').forEach(input => {
        input.addEventListener('change', async (e) => {
            const wallName = e.target.closest('.color-picker-btn').getAttribute('data-wall');
            const color = e.target.value;
            const colorDataURL = colorToDataURL(color); // Ù‚ÙŠÙ…Ø© HEX #FFFFFF

            if (colorDataURL && wallName) {
                ROOM_DATA.textures[wallName] = colorDataURL; // ØªØ®Ø²ÙŠÙ† Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³Ø¯Ø§Ø³ÙŠØ©

                const preview = document.getElementById(`preview-${wallName}`);
                if (preview) {
                    preview.innerHTML = `<small style="background-color: ${color}; width: 100%; height: 100%; display: block;"></small>`;
                }
                await buildScene(); 
            }
        });
    });


    // Ù…Ø¹Ø§Ù„Ø¬ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø© ÙˆÙ†Ø§ÙØ°Ø© Ø§Ù„Ù‚Øµ
    document.querySelectorAll('.file-input').forEach(input => {
        input.addEventListener('change', async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            
            const fileRow = e.target.closest('.file-row');
            currentWallToCrop = fileRow.querySelector('.color-picker-btn').getAttribute('data-wall');
            const base64Url = await fileToBase64(file);
            
            const cropTool = document.getElementById('crop-tool');
            const cropImage = document.getElementById('crop-image');
            
            document.getElementById('rotate-slider').value = 0;
            document.getElementById('rotate-value').value = 0;

            if (cropperInstance) {
                cropperInstance.destroy();
            }
            
            cropImage.src = base64Url;
            cropTool.style.display = 'flex';

            setTimeout(() => {
                cropperInstance = new Cropper(cropImage, {
                    viewMode: 1, 
                    dragMode: 'move', 
                    aspectRatio: NaN, 
                    autoCropArea: 0.8, 
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    responsive: true,
                    restore: false
                });
            }, 100);
            
            e.target.value = '';
        });
    });
    
    // ğŸ’¡ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø¯Ù‚ÙŠÙ‚
    const rotateSlider = document.getElementById('rotate-slider');
    const rotateValue = document.getElementById('rotate-value');

    const updateRotation = (value) => {
        if (!cropperInstance) return;
        cropperInstance.rotateTo(parseFloat(value));
    };

    rotateSlider.addEventListener('input', (e) => {
        const value = e.target.value;
        rotateValue.value = value;
        updateRotation(value);
    });

    rotateValue.addEventListener('change', (e) => {
        const value = Math.max(-360, Math.min(360, parseFloat(e.target.value))); 
        rotateSlider.value = value;
        e.target.value = value;
        updateRotation(value);
    });

    // ğŸ’¡ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø§Ù†Ø¹ÙƒØ§Ø³
    document.getElementById('crop-controls').addEventListener('click', (e) => {
        const target = e.target;
        const method = target.getAttribute('data-method');
        const option = target.getAttribute('data-option');
        
        if (!cropperInstance || !method) return;

        if (method === 'scaleX') {
            cropperInstance.scaleX(cropperInstance.getData().scaleX === 1 ? -1 : 1);
        } else if (method === 'scaleY') {
            cropperInstance.scaleY(cropperInstance.getData().scaleY === 1 ? -1 : 1);
        }
    });

    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚Øµ
    document.getElementById('crop-apply').addEventListener('click', async () => {
        const cropTool = document.getElementById('crop-tool');
        const wallName = currentWallToCrop;

        try {
            if (!cropperInstance) return;

            // ğŸ’¡ ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¬ÙˆØ¯Ø© ÙˆØ­Ø¬Ù… Ø§Ù„ØµÙˆØ±Ø© Ù„Ø­Ù„ Ù…Ø´ÙƒÙ„Ø© ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø°Ø§ÙƒØ±Ø© (JPEG Ø¨Ø¬ÙˆØ¯Ø© 0.7)
            const croppedDataURL = cropperInstance.getCroppedCanvas({
                fillColor: '#fff',
                imageSmoothingEnabled: true,
                imageSmoothingQuality: 'high',
            }).toDataURL('image/jpeg', 0.7); 

            if (croppedDataURL && wallName) {
                ROOM_DATA.textures[wallName] = croppedDataURL;

                const preview = document.getElementById(`preview-${wallName}`);
                if (preview) preview.innerHTML = `<img src="${croppedDataURL}">`;
                
                await buildScene(); 
            }
        } catch (error) {
            console.error("âŒ Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚Øµ Ø£Ùˆ Ø§Ù„Ø­ÙØ¸:", error);
            alert("ÙØ´Ù„ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚Øµ. Ù‚Ø¯ ØªÙƒÙˆÙ† Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù…Ù…ØªÙ„Ø¦Ø©. Ø­Ø§ÙˆÙ„ Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª.");
        } finally {
            // ğŸ’¡ Ø¶Ù…Ø§Ù† ØªØ¯Ù…ÙŠØ± Cropper ÙˆØ¥Ø®ÙØ§Ø¡ Ø§Ù„Ù†Ø§ÙØ°Ø© ÙÙŠ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø­ÙˆØ§Ù„
            if (cropperInstance) {
                cropperInstance.destroy();
                cropperInstance = null;
            }
            cropTool.style.display = 'none';
            currentWallToCrop = null;
        }
    });

    // Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù‚Øµ
    document.getElementById('crop-cancel').addEventListener('click', () => {
        if (cropperInstance) {
            cropperInstance.destroy(); 
        }
        document.getElementById('crop-tool').style.display = 'none';
        currentWallToCrop = null;
    });

    // Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª
    document.getElementById('clear-saved').addEventListener('click', () => {
        if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØºØ±ÙØ© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ')) {
            localStorage.removeItem('room_config');
            window.location.reload(); 
        }
    });

    // Ø¯Ø§Ù„Ø© Ø§Ù„ØªØµØ¯ÙŠØ± GLB
    document.getElementById('exportGLB').addEventListener('click', async ()=>{
        if(sceneGroup.children.length === 0){
            alert('ÙŠØ¬Ø¨ Ø¨Ù†Ø§Ø¡ Ø§Ù„ØºØ±ÙØ© Ø£ÙˆÙ„Ø§Ù‹.');
            return;
        }
        
        const exporter = new THREE.GLTFExporter(); 
        
        try {
            const gltfBinary = await new Promise((resolve, reject) => {
                exporter.parse(sceneGroup, resolve, { binary: true, embedImages: true }, reject);
            });

            if (!gltfBinary || !(gltfBinary instanceof ArrayBuffer) || gltfBinary.byteLength < 50) {
                throw new Error('gltfBinary ØºÙŠØ± ØµØ§Ù„Ø­ Ø£Ùˆ ÙØ§Ø±Øº. (Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØµØ¯ÙŠØ±).');
            }
            
            const blob = new Blob([gltfBinary], { type: 'model/gltf-binary' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'Room_Model_Final.glb';
            a.click();
            URL.revokeObjectURL(a.href);

        } catch (error) {
            console.error('âŒ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØµØ¯ÙŠØ±:', error);
            alert('ÙØ´Ù„ Ø­ÙØ¸ GLB. ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ­Ø¯Ø© Ø§Ù„ØªØ­ÙƒÙ… (Console).');
        }
    });

    // Ø¯Ø§Ù„Ø© ØªØ­Ù…ÙŠÙ„ GLB
    document.getElementById('importGLB').addEventListener('change', (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);

        const loader = new THREE.GLTFLoader(); 
        
        loader.load(url, (gltf) => {
            scene.remove(sceneGroup); 
            disposeThreeObjects(sceneGroup);
            sceneGroup = new THREE.Group();
            
            const imported = gltf.scene;
            sceneGroup.add(imported);
            scene.add(sceneGroup); 

            updateCameraPosition(ROOM_DATA.length, ROOM_DATA.width, ROOM_DATA.height);

            URL.revokeObjectURL(url);
            document.getElementById('exportGLB').disabled = false;
            alert('ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØºØ±ÙØ© Ø¨Ù†Ø¬Ø§Ø­.');
        }, undefined, (err) => {
            console.error('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ GLB:', err);
            alert('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ GLB.');
        });
    });

    // Ù…Ø¹Ø§Ù„Ø¬ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©
    document.getElementById('fullscreen-btn').addEventListener('click', () => {
        const canvas = document.getElementById('canvas3d');
        const overlay = document.getElementById('canvas-overlay-tools');
        const btn = document.getElementById('fullscreen-btn');

        isFullscreen = !isFullscreen;

        if (isFullscreen) {
            canvas.classList.add('fullscreen-canvas');
            btn.textContent = 'âŒ'; 
            overlay.style.position = 'fixed';
            overlay.style.zIndex = 1000;
        } else {
            canvas.classList.remove('fullscreen-canvas');
            btn.textContent = 'â—»ï¸';
            overlay.style.position = 'absolute';
            overlay.style.zIndex = 10;
        }
        updateRendererSize();
    });

    // Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø´Ø¯Ø© Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø©
    document.getElementById('light-intensity').addEventListener('input', (e) => {
        const intensity = parseFloat(e.target.value);
        if (directionalLight) {
            directionalLight.intensity = intensity;
        }
        if (ambientLight) {
            ambientLight.intensity = intensity / 2;
        }
        saveStateToLocalStorage();
    });
}

// Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
window.addEventListener('DOMContentLoaded', async ()=>{
    setupEventListeners(); 
    initThree();
    await buildScene(); 
});
</script>

</body>
</html>
