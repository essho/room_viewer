<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>مصمم الغرف ثلاثي الأبعاد - نسخة Pro (IDB)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- توقع وجود هذه الملفات محليًا -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.js"></script>
  <script src="./GLTFExporter.js"></script>
  <script src="./GLTFLoader.js"></script>

  <style>
    :root { --bg:#f6f7fb; --panel:#eef0f4; --ink:#1f2937; --line:#dadde3; --brand:#2563eb; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:var(--bg); color:#111; min-height:100vh; display:flex; flex-direction:column; }

    header { background:var(--ink); color:#fff; padding:10px 14px; display:flex; align-items:center; justify-content:space-between; }
    header h2 { margin:0; font-size:18px; }

    #toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:stretch; padding:10px; background:var(--panel); border-bottom:1px solid var(--line); overflow-x:auto; scroll-snap-type:x mandatory; }
    .control-group { min-width:200px; scroll-snap-align:start; background:#fff; border:1px solid var(--line); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px; }
    .control-group h4 { margin:0; font-size:13px; font-weight:700; color:#111; padding-bottom:6px; border-bottom:1px dashed #e7e7e7; }

    .dim-input { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:13px; }
    .dim-input input { width:80px; padding:6px 7px; border:1px solid #c9d0dc; border-radius:6px; font-size:13px; }

    .file-row { display:flex; align-items:center; gap:6px; justify-content:space-between; font-size:12px; }
    .file-row > label:first-child { min-width:60px; }
    .file-upload-btn { display:inline-block; padding:6px 8px; border:1px solid #cbd3df; border-radius:6px; background:#fff; cursor:pointer; }
    .file-upload-btn input { display:none; }
    .preview { border:1px dashed #cbd3df; border-radius:6px; height:36px; width:36px; display:flex; align-items:center; justify-content:center; overflow:hidden; background:#fafbff; flex-shrink:0; }
    .preview img { max-width:100%; max-height:100%; display:block; object-fit:cover; }

    .btn { padding:7px 10px; border:1px solid #cbd3df; border-radius:8px; background:#fff; cursor:pointer; font-size:13px; }
    .btn.primary { background:var(--brand); color:#fff; border-color:var(--brand); }
    .btn:disabled { opacity:.6; cursor:not-allowed; }

    #viewer-wrap { position:relative; flex:1 1 auto; min-height:280px; background:#cfd5e1; }
    canvas#canvas3d { display:block; width:100%; height:100%; }
    #fullscreen-btn { position:absolute; top:12px; right:12px; z-index:10; background:rgba(0,0,0,.65); color:#fff; border:none; border-radius:8px; padding:6px 10px; font-size:18px; cursor:pointer; line-height:1; backdrop-filter:blur(2px); }
    #fullscreen-btn:active { transform: translateY(1px); }

    #crop-tool { display:none; position:fixed; inset:0; z-index:1000; background:rgba(0,0,0,.92); align-items:center; justify-content:center; padding:16px; }
    #crop-tool-content { max-width:95vw; max-height:92vh; width:980px; background:#fff; border-radius:12px; padding:10px 12px 14px; display:flex; flex-direction:column; gap:8px; }
    #crop-toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; border:1px solid #e8ecf3; padding:8px; border-radius:8px; background:#f8fafc; }
    #crop-toolbar .btn { padding:6px 8px; font-size:12px; }
    #crop-toolbar .range { display:inline-flex; align-items:center; gap:6px; font-size:12px; }
    #crop-toolbar input[type=range]{ width:160px; }
    #crop-canvas-wrap { position:relative; overflow:auto; border:1px solid #e3e6ee; border-radius:10px; background:#f9fafc; }
    #crop-canvas { display:block; max-width:100%; max-height:66vh; background:#fff; cursor:crosshair; }

    @media (max-width: 640px){
      .control-group { min-width:180px; }
      .dim-input input { width:72px; }
      .btn { padding:6px 8px; font-size:12px; }
      #fullscreen-btn { font-size:16px; padding:6px 9px; }
      #crop-toolbar input[type=range]{ width:120px; }
    }
  </style>
</head>
<body>

  <header><h2>مصمم الغرف ثلاثي الأبعاد (Pro)</h2></header>

  <!-- الأدوات -->
  <div id="toolbar">
    <div class="control-group">
      <h4>مقاسات الغرفة (متر)</h4>
      <div class="dim-input"><label for="room-length">الطول (X)</label><input type="number" id="room-length" value="5" step="0.1" min="1"></div>
      <div class="dim-input"><label for="room-width">العرض (Z)</label><input type="number" id="room-width" value="5" step="0.1" min="1"></div>
      <div class="dim-input"><label for="room-height">الارتفاع (Y)</label><input type="number" id="room-height" value="3" step="0.1" min="2"></div>
      <button class="btn primary" id="update-room">إنشاء/تحديث</button>
    </div>

    <div class="control-group">
      <h4>صور الجدران</h4>
      <div class="file-row">
        <label>أمامي</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="front"></label>
        <div class="preview" id="preview-front"></div>
      </div>
      <div class="file-row">
        <label>خلفي</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="back"></label>
        <div class="preview" id="preview-back"></div>
      </div>
      <div class="file-row">
        <label>أيسر</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="left"></label>
        <div class="preview" id="preview-left"></div>
      </div>
      <div class="file-row">
        <label>أيمن</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="right"></label>
        <div class="preview" id="preview-right"></div>
      </div>
    </div>

    <div class="control-group">
      <h4>أرضية وسقف</h4>
      <div class="file-row">
        <label>أرضية</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="floor"></label>
        <div class="preview" id="preview-floor"></div>
      </div>
      <div class="file-row">
        <label>سقف</label><label class="file-upload-btn">رفع
          <input type="file" accept="image/*" data-wall="ceiling"></label>
        <div class="preview" id="preview-ceiling"></div>
      </div>
    </div>

    <div class="control-group">
      <h4>إجراءات</h4>
      <button class="btn primary" id="exportGLB" disabled>💾 حفظ GLB</button>
      <label class="btn">📂 تحميل GLB
        <input type="file" id="importGLB" accept=".glb,.gltf"></label>
      <button class="btn" id="clear-saved">🗑️ مسح المحفوظات</button>
    </div>
  </div>

  <!-- العارض -->
  <div id="viewer-wrap">
    <button id="fullscreen-btn" title="تكبير/تصغير">⛶</button>
    <canvas id="canvas3d"></canvas>
  </div>

  <!-- أداة القص -->
  <div id="crop-tool" aria-hidden="true">
    <div id="crop-tool-content" role="dialog" aria-modal="true">
      <div id="crop-toolbar">
        <button class="btn" id="zoom-in">➕ تكبير</button>
        <button class="btn" id="zoom-out">➖ تصغير</button>
        <button class="btn" id="rotate-90">🔄 90°</button>
        <span class="range">↺ زاوية: <input type="range" id="rotate-range" min="-180" max="180" value="0"></span>
        <button class="btn" id="reset-view">إعادة تعيين</button>
        <div style="flex:1"></div>
        <button class="btn" id="crop-cancel">إلغاء</button>
        <button class="btn primary" id="crop-apply">تطبيق</button>
      </div>
      <div id="crop-canvas-wrap"><canvas id="crop-canvas"></canvas></div>
    </div>
  </div>

  <script>
    // ============ متغيرات عامة ============
    let renderer, scene, camera, controls;
    let sceneGroup = new THREE.Group();
    const textureLoader = new THREE.TextureLoader();

    const ROOM = {
      length: 5, width: 5, height: 3,
      textures: { front:null, back:null, left:null, right:null, floor:null, ceiling:null }
    };
    const DEFAULTS = { wall:0xcccccc, floor:0x333333, ceiling:0xffffff, camEye:1.6 };

    // ======== مفاتيح/ثوابت عامة ========
    const KEYS = ['front','back','left','right','floor','ceiling'];
    const LS_PREFIX = 'room_pro_';
    const lsKey = k => `${LS_PREFIX}${k}`;
    for (const k of KEYS) if (!(k in ROOM.textures)) ROOM.textures[k] = null;

    // ======== IndexedDB (تخزين الصور) ========
    const DB_NAME = 'room_pro_db';
    const DB_STORE = 'textures';

    function idbOpen(){ return new Promise((resolve, reject)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = ()=>{ const db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE); };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });}
    function idbPut(key, blob){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).put(blob, key);
      tx.oncomplete=()=>{ db.close(); resolve(); }; tx.onerror=()=>{ db.close(); reject(tx.error); };
    }));}
    function idbGet(key){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readonly'); const req = tx.objectStore(DB_STORE).get(key);
      req.onsuccess=()=>{ const v=req.result||null; db.close(); resolve(v); };
      req.onerror=()=>{ db.close(); reject(req.error); };
    }));}
    function idbClear(){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).clear();
      tx.oncomplete=()=>{ db.close(); resolve(); }; tx.onerror=()=>{ db.close(); reject(tx.error); };
    }));}

    // ======== أدوات ضغط/تحويل ========
    function loadImage(dataURL){ return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=dataURL; }); }
    function canvasToBlob(canvas, mime='image/jpeg', quality=0.75){ return new Promise(res=>canvas.toBlob(b=>res(b||new Blob()), mime, quality)); }

    // حفظ خامة: ضغط→Blob→IndexedDB، ثم توليد URL للاستخدام
    async function saveTexture(key, dataURL){
      const im = await loadImage(dataURL);
      const sizes = [1280, 1024, 800, 640, 480];
      const quals = [0.75, 0.65, 0.6, 0.55, 0.5];
      let savedBlob = null, lastErr=null;

      for (let i=0;i<sizes.length;i++){
        const maxDim = sizes[i], q = quals[i];
        const scale = Math.min(1, maxDim/im.width, maxDim/im.height);
        const w = Math.max(1, Math.round(im.width*scale));
        const h = Math.max(1, Math.round(im.height*scale));
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        const cx = c.getContext('2d'); cx.drawImage(im,0,0,w,h);
        const blob = await canvasToBlob(c, 'image/jpeg', q);
        try { await idbPut('tex_'+key, blob); savedBlob = blob; lastErr=null; break; }
        catch(e){ lastErr=e; }
      }
      if (!savedBlob && lastErr){ console.warn('⚠️ IDB ممتلئ لهذه الخامة:', key, lastErr); }
      ROOM.textures[key] = savedBlob ? URL.createObjectURL(savedBlob) : null;
    }

    async function getTextureURL(key){
      const blob = await idbGet('tex_'+key);
      return blob ? URL.createObjectURL(blob) : null;
    }

    // هجرة أي تخزين قديم (المفتاح الكبير أو مفاتيح room_pro_tex_*)
    async function migrateLegacy(){
      const toMove = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k && k.startsWith('room_pro_tex_')) toMove.push(k);
      }
      for (const k of toMove){
        const val = localStorage.getItem(k);
        if (val) {
          const key = k.replace('room_pro_tex_','');
          try { await saveTexture(key, val); } catch(e){ console.warn('هجرة فشلت:', key, e); }
        }
        localStorage.removeItem(k);
      }
      const legacy = localStorage.getItem('room_config_pro');
      if (legacy){
        try {
          const data = JSON.parse(legacy);
          const tex = data.tex || {};
          for (const k of KEYS){ if (tex[k]){ try { await saveTexture(k, tex[k]); } catch(e){} } }
        } catch(e){ console.warn('هجرة المفتاح القديم فشلت:', e); }
        localStorage.removeItem('room_config_pro');
      }
    }

    // ============ حفظ/تحميل (الأبعاد فقط في LS) ============
    function saveState(){
      try {
        const dims = { L: ROOM.length, W: ROOM.width, H: ROOM.height };
        localStorage.setItem(lsKey('dims'), JSON.stringify(dims));
      } catch(e){ console.warn('⚠️ تعذر حفظ الأبعاد:', e); }
    }

    async function loadState(){
      try {
        const raw = localStorage.getItem(lsKey('dims'));
        if (raw){
          const d = JSON.parse(raw);
          ROOM.length = parseFloat(d.L) || ROOM.length;
          ROOM.width  = parseFloat(d.W) || ROOM.width;
          ROOM.height = parseFloat(d.H) || ROOM.height;
        }
      } catch {}

      // جلب كل الصور من IndexedDB
      await Promise.all(KEYS.map(async k=>{
        const url = await getTextureURL(k);
        ROOM.textures[k] = url;
      }));

      // مزامنة واجهة الحقول والمعاينات
      document.getElementById('room-length').value = ROOM.length;
      document.getElementById('room-width').value  = ROOM.width;
      document.getElementById('room-height').value = ROOM.height;
      KEYS.forEach(k=>{
        const p = document.getElementById('preview-'+k);
        if (p) p.innerHTML = ROOM.textures[k] ? '<img src="'+ROOM.textures[k]+'">' : '';
      });

      return true;
    }

    // ============ تهيئة العرض ============
    function setViewerSize(){
      const header = document.querySelector('header').offsetHeight;
      const toolbar = document.getElementById('toolbar').offsetHeight;
      const h = Math.max(280, window.innerHeight - header - toolbar);
      const wrap = document.getElementById('viewer-wrap');
      wrap.style.height = h + 'px';
      if (renderer) {
        renderer.setSize(wrap.clientWidth, wrap.clientHeight, false);
        camera.aspect = wrap.clientWidth / wrap.clientHeight;
        camera.updateProjectionMatrix();
      }
    }

    function initThree(){
      const canvas = document.getElementById('canvas3d');
      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:'high-performance' });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      if ('SRGBColorSpace' in THREE) renderer.outputColorSpace = THREE.SRGBColorSpace;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xEAEFF7);

      camera = new THREE.PerspectiveCamera(70, 16/9, 0.1, 200);
      const amb = new THREE.AmbientLight(0xffffff, 0.70);
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); dir.position.set(5, 6, 4);
      scene.add(amb, dir);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false; controls.maxPolarAngle = Math.PI * 0.9; controls.minDistance = 0.4;

      window.addEventListener('resize', setViewerSize);
      setViewerSize();
      animate();
    }
    function animate(){ requestAnimationFrame(animate); controls && controls.update(); renderer.render(scene, camera); }

    // ============ تحميل خامات ============
    function loadTexture(url){
      return new Promise((resolve)=>{
        if (!url) return resolve(null);
        textureLoader.load(url, (tex)=>{
          if ('SRGBColorSpace' in THREE) tex.colorSpace = THREE.SRGBColorSpace;
          tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
          try { const aniso = renderer.capabilities.getMaxAnisotropy?.() || 0; if (aniso) tex.anisotropy = aniso; } catch {}
          resolve(tex);
        }, undefined, ()=>resolve(null));
      });
    }

    async function buildRoom(){
      const L = parseFloat(ROOM.length), W = parseFloat(ROOM.width), H = parseFloat(ROOM.height);

      scene.remove(sceneGroup);
      disposeGroup(sceneGroup);
      sceneGroup = new THREE.Group();

      const tex = {};
      for (const k of KEYS) tex[k] = await loadTexture(ROOM.textures[k]);

      const wallDefs = [
        { name:'Front_Wall', size:[L,H], pos:[0,0,-W/2], rot:[0, 0, 0],        key:'front'   },
        { name:'Back_Wall',  size:[L,H], pos:[0,0, W/2], rot:[0, Math.PI, 0],  key:'back'    },
        { name:'Right_Wall', size:[W,H], pos:[L/2,0, 0], rot:[0,-Math.PI/2,0], key:'right'   },
        { name:'Left_Wall',  size:[W,H], pos:[-L/2,0,0], rot:[0, Math.PI/2,0], key:'left'    },
        { name:'Floor',      size:[L,W], pos:[0,-H/2,0], rot:[-Math.PI/2,0,0], key:'floor'   },
        { name:'Ceiling',    size:[L,W], pos:[0, H/2,0], rot:[ Math.PI/2,0,0], key:'ceiling' }
      ];

      for (const w of wallDefs){
        const map = tex[w.key];
        const material = new THREE.MeshStandardMaterial({
          map, side: THREE.DoubleSide,
          color: map ? 0xffffff : (w.key==='floor'?DEFAULTS.floor:(w.key==='ceiling'?DEFAULTS.ceiling:DEFAULTS.wall))
        });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(...w.size), material);
        mesh.position.set(...w.pos); mesh.rotation.set(...w.rot);

        if (map && map.image && map.image.width && map.image.height){
          const wallRatio = w.size[0] / w.size[1];
          const imgRatio  = map.image.width / map.image.height;
          if (imgRatio > wallRatio) map.repeat.set(wallRatio / imgRatio, 1);
          else map.repeat.set(1, imgRatio / wallRatio);
          map.offset.set((1 - map.repeat.x) / 2, (1 - map.repeat.y) / 2);
          map.needsUpdate = true;
        }
        sceneGroup.add(mesh);
      }

      camera.position.set(0, DEFAULTS.camEye - H/2, Math.max(L, W) * 0.95);
      controls.target.set(0, DEFAULTS.camEye - H/2, 0);
      controls.update();

      scene.add(sceneGroup);
      document.getElementById('exportGLB').disabled = sceneGroup.children.length === 0;
      saveState(); // يحفظ الأبعاد فقط في LS
    }

    function disposeGroup(group){
      group.traverse((obj)=>{
        if (obj.isMesh){
          obj.geometry?.dispose?.();
          if (Array.isArray(obj.material)){
            obj.material.forEach(m=>{ m.map?.dispose?.(); m.dispose?.(); });
          } else { obj.material?.map?.dispose?.(); obj.material?.dispose?.(); }
        }
      });
    }

    // ============ أداة القص ============
    const cropTool   = document.getElementById('crop-tool');
    const cropCanvas = document.getElementById('crop-canvas');
    const ctx        = cropCanvas.getContext('2d');
    let img = new Image(), cropWallKey = null;

    let zoom=1, minZoom=0.1, maxZoom=6, angle=0, panX=0, panY=0;
    let draggingImage=false, lastX=0, lastY=0;

    let sel = { x:50, y:50, w:200, h:120 };
    const HANDLE = 8;
    let dragMode = null;
    function handles(){ return [
      {k:'nw', x:sel.x, y:sel.y}, {k:'ne', x:sel.x+sel.w, y:sel.y},
      {k:'sw', x:sel.x, y:sel.y+sel.h}, {k:'se', x:sel.x+sel.w, y:sel.y+sel.h},
      {k:'n', x:sel.x+sel.w/2, y:sel.y}, {k:'s', x:sel.x+sel.w/2, y:sel.y+sel.h},
      {k:'w', x:sel.x, y:sel.y+sel.h/2}, {k:'e', x:sel.x+sel.w, y:sel.y+sel.h/2},
    ];}
    function hitHandle(mx,my){
      const hs = handles();
      for (const h of hs){ if (Math.abs(mx-h.x)<=HANDLE && Math.abs(my-h.y)<=HANDLE) return h.k; }
      if (mx>=sel.x && mx<=sel.x+sel.w && my>=sel.y && my<=sel.y+sel.h) return 'move';
      return null;
    }

    function openCropUI(dataURL, wallKey){
      cropWallKey = wallKey;
      img = new Image();
      img.onload = ()=>{
        const maxW = Math.min(1800, window.innerWidth*0.9);
        const maxH = Math.min(1000, window.innerHeight*0.66);
        let cw = img.width, ch = img.height;
        const scale = Math.min(maxW/cw, maxH/ch, 1);
        cw = Math.floor(cw*scale); ch = Math.floor(ch*scale);
        cropCanvas.width = cw; cropCanvas.height = ch;

        zoom=1; angle=0; panX=0; panY=0;
        sel = { x:cw*0.2, y:ch*0.2, w:cw*0.6, h:ch*0.6 };
        document.getElementById('rotate-range').value = 0;
        redraw();
      };
      img.src = dataURL;
      cropTool.style.display='flex';
      cropTool.setAttribute('aria-hidden','false');
    }

    function redraw(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,cropCanvas.width,cropCanvas.height);

      ctx.save();
      ctx.translate(cropCanvas.width/2 + panX, cropCanvas.height/2 + panY);
      ctx.rotate(angle);
      ctx.scale(zoom, zoom);
      ctx.drawImage(img, -img.width/2, -img.height/2);
      ctx.restore();

      ctx.save(); ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(0,0,cropCanvas.width, sel.y);
      ctx.fillRect(0, sel.y, sel.x, sel.h);
      ctx.fillRect(sel.x+sel.w, sel.y, cropCanvas.width-(sel.x+sel.w), sel.h);
      ctx.fillRect(0, sel.y+sel.h, cropCanvas.width, cropCanvas.height-(sel.y+sel.h));
      ctx.restore();

      ctx.save(); ctx.strokeStyle='#e11d48'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
      ctx.strokeRect(sel.x, sel.y, sel.w, sel.h); ctx.restore();

      ctx.save(); ctx.fillStyle='#fff'; ctx.strokeStyle='#e11d48';
      for (const h of handles()){ ctx.beginPath(); ctx.rect(h.x-HANDLE, h.y-HANDLE, HANDLE*2, HANDLE*2); ctx.fill(); ctx.stroke(); }
      ctx.restore();
    }

    cropCanvas.addEventListener('mousedown', (e)=>{
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      lastX = mx; lastY = my;
      const mode = hitHandle(mx,my);
      if (mode){ dragMode = mode; return; }
      if (e.altKey || e.which===2){ draggingImage = true; return; }
      if (!(mx>=sel.x && mx<=sel.x+sel.w && my>=sel.y && my<=sel.y+sel.h)){
        sel = { x:mx, y:my, w:0, h:0 }; dragMode='se';
      } else { dragMode='move'; }
    });
    cropCanvas.addEventListener('mousemove', (e)=>{
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const dx = mx - lastX, dy = my - lastY;

      if (draggingImage){ panX += dx; panY += dy; lastX=mx; lastY=my; redraw(); return; }

      if (dragMode){
        if (dragMode==='move'){ sel.x += dx; sel.y += dy; }
        else {
          const left=sel.x, top=sel.y, right=sel.x+sel.w, bottom=sel.y+sel.h;
          let nleft=left, nright=right, ntop=top, nbottom=bottom;
          if (dragMode.includes('w')) nleft += dx;
          if (dragMode.includes('e')) nright += dx;
          if (dragMode.includes('n')) ntop += dy;
          if (dragMode.includes('s')) nbottom += dy;
          const minSize=10;
          if (nright-nleft>=minSize){ sel.x=nleft; sel.w=nright-nleft; }
          if (nbottom-ntop>=minSize){ sel.y=ntop; sel.h=nbottom-ntop; }
        }
        lastX=mx; lastY=my; redraw(); return;
      }

      const mode2 = hitHandle(mx,my);
      const map = {n:'ns-resize',s:'ns-resize',e:'ew-resize',w:'ew-resize',ne:'nesw-resize',sw:'nesw-resize',nw:'nwse-resize',se:'nwse-resize',move:'move'};
      cropCanvas.style.cursor = mode2 ? map[mode2] : (e.altKey ? 'grab' : 'crosshair');
    });
    window.addEventListener('mouseup', ()=>{ draggingImage=false; dragMode=null; });
    cropCanvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const f = (e.deltaY<0)?1.1:0.9;
      const nz = Math.max(minZoom, Math.min(maxZoom, zoom*f));
      if (nz===zoom) return;
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const wx = mx - cropCanvas.width/2 - panX;
      const wy = my - cropCanvas.height/2 - panY;
      panX -= wx*(nz/zoom - 1);
      panY -= wy*(nz/zoom - 1);
      zoom = nz;
      redraw();
    }, {passive:false});

    document.getElementById('zoom-in').addEventListener('click', ()=>{ zoom = Math.min(maxZoom, zoom*1.2); redraw(); });
    document.getElementById('zoom-out').addEventListener('click', ()=>{ zoom = Math.max(minZoom, zoom/1.2); redraw(); });
    document.getElementById('rotate-90').addEventListener('click', ()=>{ angle += Math.PI/2; if (angle>Math.PI*2) angle-=Math.PI*2; redraw(); document.getElementById('rotate-range').value = Math.round(angle*180/Math.PI); });
    document.getElementById('rotate-range').addEventListener('input', (e)=>{ angle = parseFloat(e.target.value)*Math.PI/180; redraw(); });
    document.getElementById('reset-view').addEventListener('click', ()=>{ zoom=1; angle=0; panX=0; panY=0; redraw(); document.getElementById('rotate-range').value = 0; });

    // تطبيق القص — الحفظ في IndexedDB
    document.getElementById('crop-apply').addEventListener('click', async ()=>{
      const sx = sel.w<0 ? sel.x+sel.w : sel.x;
      const sy = sel.h<0 ? sel.y+sel.h : sel.y;
      const sw = Math.abs(sel.w), sh = Math.abs(sel.h);
      if (sw<2 || sh<2){ closeCrop(); return; }

      // ارسم الصورة (بدون مقابض) إلى كانفس مؤقت
      const temp = document.createElement('canvas');
      temp.width = cropCanvas.width; temp.height = cropCanvas.height;
      const tctx = temp.getContext('2d');
      tctx.save();
      tctx.translate(cropCanvas.width/2 + panX, cropCanvas.height/2 + panY);
      tctx.rotate(angle);
      tctx.scale(zoom, zoom);
      tctx.drawImage(img, -img.width/2, -img.height/2);
      tctx.restore();

      // ثم قص الجزء المحدد
      const out = document.createElement('canvas');
      out.width = Math.max(1, Math.round(sw));
      out.height = Math.max(1, Math.round(sh));
      out.getContext('2d').drawImage(temp, sx, sy, sw, sh, 0, 0, out.width, out.height);

      const dataURL = out.toDataURL('image/png');

      await saveTexture(cropWallKey, dataURL); // -> IndexedDB + URL
      updatePreview(cropWallKey, ROOM.textures[cropWallKey]);
      closeCrop();
      await buildRoom();
      saveState(); // الأبعاد فقط
    });

    function closeCrop(){ cropTool.style.display='none'; cropTool.setAttribute('aria-hidden','true'); cropWallKey=null; }
    document.getElementById('crop-cancel').addEventListener('click', closeCrop);

    function updatePreview(key, url){
      const p = document.getElementById('preview-'+key);
      if (p) p.innerHTML = url ? '<img src="'+url+'">' : '';
    }

    // ============ ربط مدخلات الصور ============
    document.querySelectorAll('input[type="file"][data-wall]').forEach(input=>{
      input.addEventListener('change', (e)=>{
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = (ev)=>{
          const base64 = ev.target.result;
          const key = e.target.getAttribute('data-wall');
          openCropUI(base64, key);
          e.target.value='';
        };
        reader.readAsDataURL(f);
      });
    });

    // ============ أزرار عامة ============
    document.getElementById('update-room').addEventListener('click', ()=>{
      ROOM.length = parseFloat(document.getElementById('room-length').value) || ROOM.length;
      ROOM.width  = parseFloat(document.getElementById('room-width').value)  || ROOM.width;
      ROOM.height = parseFloat(document.getElementById('room-height').value) || ROOM.height;
      buildRoom();
    });

    document.getElementById('clear-saved').addEventListener('click', async ()=>{
      if (!confirm('مسح جميع الإعدادات والصور المحفوظة؟')) return;
      try {
        await idbClear();
      } catch(e){ console.warn('مسح IDB فشل:', e); }
      localStorage.removeItem(lsKey('dims'));
      localStorage.removeItem('room_config_pro'); // لو باقي
      // تنظيف أي مفاتيح قديمة بالصدفة
      const oldKeys = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k && k.startsWith('room_pro_tex_')) oldKeys.push(k);
      }
      oldKeys.forEach(k=>localStorage.removeItem(k));

      for (const k of KEYS) ROOM.textures[k] = null;
      KEYS.forEach(k=>updatePreview(k, null));
      buildRoom();
    });

    // ============ ملء الشاشة ============
    const fsBtn = document.getElementById('fullscreen-btn');
    const viewer = document.getElementById('viewer-wrap');
    function isFS(){ return !!document.fullscreenElement; }
    fsBtn.addEventListener('click', ()=>{ isFS() ? document.exitFullscreen() : viewer.requestFullscreen(); });
    document.addEventListener('fullscreenchange', ()=>{ fsBtn.textContent = isFS() ? '✖' : '⛶'; setViewerSize(); });

    // ============ تصدير / استيراد GLB ============
    document.getElementById('exportGLB').addEventListener('click', async ()=>{
      if (!sceneGroup || sceneGroup.children.length===0){ alert('ابنِ الغرفة أولًا'); return; }
      const exporter = new THREE.GLTFExporter();
      try {
        const glb = await new Promise((resolve,reject)=>{ exporter.parse(sceneGroup, resolve, { binary:true, embedImages:true }, reject); });
        const blob = new Blob([glb], {type:'model/gltf-binary'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = 'Room.glb';
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
      } catch(err){ console.error('فشل التصدير:', err); alert('فشل التصدير إلى GLB'); }
    });

    document.getElementById('importGLB').addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const loader = new THREE.GLTFLoader();
      loader.load(url, (gltf)=>{
        scene.remove(sceneGroup);
        disposeGroup(sceneGroup);
        sceneGroup = new THREE.Group();
        const imported = gltf.scene;
        sceneGroup.add(imported);
        scene.add(sceneGroup);
        const box = new THREE.Box3().setFromObject(imported);
        const center = new THREE.Vector3(); box.getCenter(center);
        controls.target.copy(center); controls.update();
        document.getElementById('exportGLB').disabled = false;
        URL.revokeObjectURL(url);
        alert('تم التحميل.');
      }, undefined, (err)=>{ console.error('GLB فشل التحميل:', err); alert('فشل تحميل GLB'); });
    });

    // ============ تشغيل ============
    window.addEventListener('DOMContentLoaded', async ()=>{
      initThree();
      // هجرة أي تخزين قديم (مرة واحدة)
      await migrateLegacy();
      await loadState();     // يجلب الأبعاد + URLs من IDB
      await buildRoom();     // يبني فورًا
    });
  </script>
</body>
</html>
