<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <title>Ù…ØµÙ…Ù… Ø§Ù„ØºØ±Ù Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ - Ù†Ø³Ø®Ø© Pro (IDB)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- ØªÙˆÙ‚Ø¹ ÙˆØ¬ÙˆØ¯ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ø­Ù„ÙŠÙ‹Ø§ -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.js"></script>
  <script src="./GLTFExporter.js"></script>
  <script src="./GLTFLoader.js"></script>

  <style>
    :root { --bg:#f6f7fb; --panel:#eef0f4; --ink:#1f2937; --line:#dadde3; --brand:#2563eb; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; background:var(--bg); color:#111; min-height:100vh; display:flex; flex-direction:column; }

    header { background:var(--ink); color:#fff; padding:10px 14px; display:flex; align-items:center; justify-content:space-between; }
    header h2 { margin:0; font-size:18px; }

    #toolbar { display:flex; flex-wrap:wrap; gap:10px; align-items:stretch; padding:10px; background:var(--panel); border-bottom:1px solid var(--line); overflow-x:auto; scroll-snap-type:x mandatory; }
    .control-group { min-width:200px; scroll-snap-align:start; background:#fff; border:1px solid var(--line); border-radius:8px; padding:10px; display:flex; flex-direction:column; gap:8px; }
    .control-group h4 { margin:0; font-size:13px; font-weight:700; color:#111; padding-bottom:6px; border-bottom:1px dashed #e7e7e7; }

    .dim-input { display:flex; align-items:center; justify-content:space-between; gap:8px; font-size:13px; }
    .dim-input input { width:80px; padding:6px 7px; border:1px solid #c9d0dc; border-radius:6px; font-size:13px; }

    .file-row { display:flex; align-items:center; gap:6px; justify-content:space-between; font-size:12px; }
    .file-row > label:first-child { min-width:60px; }
    .file-upload-btn { display:inline-block; padding:6px 8px; border:1px solid #cbd3df; border-radius:6px; background:#fff; cursor:pointer; }
    .file-upload-btn input { display:none; }
    .preview { border:1px dashed #cbd3df; border-radius:6px; height:36px; width:36px; display:flex; align-items:center; justify-content:center; overflow:hidden; background:#fafbff; flex-shrink:0; }
    .preview img { max-width:100%; max-height:100%; display:block; object-fit:cover; }

    .btn { padding:7px 10px; border:1px solid #cbd3df; border-radius:8px; background:#fff; cursor:pointer; font-size:13px; }
    .btn.primary { background:var(--brand); color:#fff; border-color:var(--brand); }
    .btn:disabled { opacity:.6; cursor:not-allowed; }

    #viewer-wrap { position:relative; flex:1 1 auto; min-height:280px; background:#cfd5e1; }
    canvas#canvas3d { display:block; width:100%; height:100%; }
    #fullscreen-btn { position:absolute; top:12px; right:12px; z-index:10; background:rgba(0,0,0,.65); color:#fff; border:none; border-radius:8px; padding:6px 10px; font-size:18px; cursor:pointer; line-height:1; backdrop-filter:blur(2px); }
    #fullscreen-btn:active { transform: translateY(1px); }

    #crop-tool { display:none; position:fixed; inset:0; z-index:1000; background:rgba(0,0,0,.92); align-items:center; justify-content:center; padding:16px; }
    #crop-tool-content { max-width:95vw; max-height:92vh; width:980px; background:#fff; border-radius:12px; padding:10px 12px 14px; display:flex; flex-direction:column; gap:8px; }
    #crop-toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; border:1px solid #e8ecf3; padding:8px; border-radius:8px; background:#f8fafc; }
    #crop-toolbar .btn { padding:6px 8px; font-size:12px; }
    #crop-toolbar .range { display:inline-flex; align-items:center; gap:6px; font-size:12px; }
    #crop-toolbar input[type=range]{ width:160px; }
    #crop-canvas-wrap { position:relative; overflow:auto; border:1px solid #e3e6ee; border-radius:10px; background:#f9fafc; }
    #crop-canvas { display:block; max-width:100%; max-height:66vh; background:#fff; cursor:crosshair; }

    @media (max-width: 640px){
      .control-group { min-width:180px; }
      .dim-input input { width:72px; }
      .btn { padding:6px 8px; font-size:12px; }
      #fullscreen-btn { font-size:16px; padding:6px 9px; }
      #crop-toolbar input[type=range]{ width:120px; }
    }
  </style>
</head>
<body>

  <header><h2>Ù…ØµÙ…Ù… Ø§Ù„ØºØ±Ù Ø«Ù„Ø§Ø«ÙŠ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ (Pro)</h2></header>

  <!-- Ø§Ù„Ø£Ø¯ÙˆØ§Øª -->
  <div id="toolbar">
    <div class="control-group">
      <h4>Ù…Ù‚Ø§Ø³Ø§Øª Ø§Ù„ØºØ±ÙØ© (Ù…ØªØ±)</h4>
      <div class="dim-input"><label for="room-length">Ø§Ù„Ø·ÙˆÙ„ (X)</label><input type="number" id="room-length" value="5" step="0.1" min="1"></div>
      <div class="dim-input"><label for="room-width">Ø§Ù„Ø¹Ø±Ø¶ (Z)</label><input type="number" id="room-width" value="5" step="0.1" min="1"></div>
      <div class="dim-input"><label for="room-height">Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ (Y)</label><input type="number" id="room-height" value="3" step="0.1" min="2"></div>
      <button class="btn primary" id="update-room">Ø¥Ù†Ø´Ø§Ø¡/ØªØ­Ø¯ÙŠØ«</button>
    </div>

    <div class="control-group">
      <h4>ØµÙˆØ± Ø§Ù„Ø¬Ø¯Ø±Ø§Ù†</h4>
      <div class="file-row">
        <label>Ø£Ù…Ø§Ù…ÙŠ</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="front"></label>
        <div class="preview" id="preview-front"></div>
      </div>
      <div class="file-row">
        <label>Ø®Ù„ÙÙŠ</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="back"></label>
        <div class="preview" id="preview-back"></div>
      </div>
      <div class="file-row">
        <label>Ø£ÙŠØ³Ø±</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="left"></label>
        <div class="preview" id="preview-left"></div>
      </div>
      <div class="file-row">
        <label>Ø£ÙŠÙ…Ù†</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="right"></label>
        <div class="preview" id="preview-right"></div>
      </div>
    </div>

    <div class="control-group">
      <h4>Ø£Ø±Ø¶ÙŠØ© ÙˆØ³Ù‚Ù</h4>
      <div class="file-row">
        <label>Ø£Ø±Ø¶ÙŠØ©</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="floor"></label>
        <div class="preview" id="preview-floor"></div>
      </div>
      <div class="file-row">
        <label>Ø³Ù‚Ù</label><label class="file-upload-btn">Ø±ÙØ¹
          <input type="file" accept="image/*" data-wall="ceiling"></label>
        <div class="preview" id="preview-ceiling"></div>
      </div>
    </div>

    <div class="control-group">
      <h4>Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª</h4>
      <button class="btn primary" id="exportGLB" disabled>ğŸ’¾ Ø­ÙØ¸ GLB</button>
      <label class="btn">ğŸ“‚ ØªØ­Ù…ÙŠÙ„ GLB
        <input type="file" id="importGLB" accept=".glb,.gltf"></label>
      <button class="btn" id="clear-saved">ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø§Øª</button>
    </div>
  </div>

  <!-- Ø§Ù„Ø¹Ø§Ø±Ø¶ -->
  <div id="viewer-wrap">
    <button id="fullscreen-btn" title="ØªÙƒØ¨ÙŠØ±/ØªØµØºÙŠØ±">â›¶</button>
    <canvas id="canvas3d"></canvas>
  </div>

  <!-- Ø£Ø¯Ø§Ø© Ø§Ù„Ù‚Øµ -->
  <div id="crop-tool" aria-hidden="true">
    <div id="crop-tool-content" role="dialog" aria-modal="true">
      <div id="crop-toolbar">
        <button class="btn" id="zoom-in">â• ØªÙƒØ¨ÙŠØ±</button>
        <button class="btn" id="zoom-out">â– ØªØµØºÙŠØ±</button>
        <button class="btn" id="rotate-90">ğŸ”„ 90Â°</button>
        <span class="range">â†º Ø²Ø§ÙˆÙŠØ©: <input type="range" id="rotate-range" min="-180" max="180" value="0"></span>
        <button class="btn" id="reset-view">Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†</button>
        <div style="flex:1"></div>
        <button class="btn" id="crop-cancel">Ø¥Ù„ØºØ§Ø¡</button>
        <button class="btn primary" id="crop-apply">ØªØ·Ø¨ÙŠÙ‚</button>
      </div>
      <div id="crop-canvas-wrap"><canvas id="crop-canvas"></canvas></div>
    </div>
  </div>

  <script>
    // ============ Ù…ØªØºÙŠØ±Ø§Øª Ø¹Ø§Ù…Ø© ============
    let renderer, scene, camera, controls;
    let sceneGroup = new THREE.Group();
    const textureLoader = new THREE.TextureLoader();

    const ROOM = {
      length: 5, width: 5, height: 3,
      textures: { front:null, back:null, left:null, right:null, floor:null, ceiling:null }
    };
    const DEFAULTS = { wall:0xcccccc, floor:0x333333, ceiling:0xffffff, camEye:1.6 };

    // ======== Ù…ÙØ§ØªÙŠØ­/Ø«ÙˆØ§Ø¨Øª Ø¹Ø§Ù…Ø© ========
    const KEYS = ['front','back','left','right','floor','ceiling'];
    const LS_PREFIX = 'room_pro_';
    const lsKey = k => `${LS_PREFIX}${k}`;
    for (const k of KEYS) if (!(k in ROOM.textures)) ROOM.textures[k] = null;

    // ======== IndexedDB (ØªØ®Ø²ÙŠÙ† Ø§Ù„ØµÙˆØ±) ========
    const DB_NAME = 'room_pro_db';
    const DB_STORE = 'textures';

    function idbOpen(){ return new Promise((resolve, reject)=>{
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = ()=>{ const db = req.result; if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE); };
      req.onsuccess = ()=>resolve(req.result);
      req.onerror = ()=>reject(req.error);
    });}
    function idbPut(key, blob){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).put(blob, key);
      tx.oncomplete=()=>{ db.close(); resolve(); }; tx.onerror=()=>{ db.close(); reject(tx.error); };
    }));}
    function idbGet(key){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readonly'); const req = tx.objectStore(DB_STORE).get(key);
      req.onsuccess=()=>{ const v=req.result||null; db.close(); resolve(v); };
      req.onerror=()=>{ db.close(); reject(req.error); };
    }));}
    function idbClear(){ return idbOpen().then(db=> new Promise((resolve,reject)=>{
      const tx = db.transaction(DB_STORE,'readwrite'); tx.objectStore(DB_STORE).clear();
      tx.oncomplete=()=>{ db.close(); resolve(); }; tx.onerror=()=>{ db.close(); reject(tx.error); };
    }));}

    // ======== Ø£Ø¯ÙˆØ§Øª Ø¶ØºØ·/ØªØ­ÙˆÙŠÙ„ ========
    function loadImage(dataURL){ return new Promise((res,rej)=>{ const im=new Image(); im.onload=()=>res(im); im.onerror=rej; im.src=dataURL; }); }
    function canvasToBlob(canvas, mime='image/jpeg', quality=0.75){ return new Promise(res=>canvas.toBlob(b=>res(b||new Blob()), mime, quality)); }

    // Ø­ÙØ¸ Ø®Ø§Ù…Ø©: Ø¶ØºØ·â†’Blobâ†’IndexedDBØŒ Ø«Ù… ØªÙˆÙ„ÙŠØ¯ URL Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
    async function saveTexture(key, dataURL){
      const im = await loadImage(dataURL);
      const sizes = [1280, 1024, 800, 640, 480];
      const quals = [0.75, 0.65, 0.6, 0.55, 0.5];
      let savedBlob = null, lastErr=null;

      for (let i=0;i<sizes.length;i++){
        const maxDim = sizes[i], q = quals[i];
        const scale = Math.min(1, maxDim/im.width, maxDim/im.height);
        const w = Math.max(1, Math.round(im.width*scale));
        const h = Math.max(1, Math.round(im.height*scale));
        const c = document.createElement('canvas'); c.width=w; c.height=h;
        const cx = c.getContext('2d'); cx.drawImage(im,0,0,w,h);
        const blob = await canvasToBlob(c, 'image/jpeg', q);
        try { await idbPut('tex_'+key, blob); savedBlob = blob; lastErr=null; break; }
        catch(e){ lastErr=e; }
      }
      if (!savedBlob && lastErr){ console.warn('âš ï¸ IDB Ù…Ù…ØªÙ„Ø¦ Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø®Ø§Ù…Ø©:', key, lastErr); }
      ROOM.textures[key] = savedBlob ? URL.createObjectURL(savedBlob) : null;
    }

    async function getTextureURL(key){
      const blob = await idbGet('tex_'+key);
      return blob ? URL.createObjectURL(blob) : null;
    }

    // Ù‡Ø¬Ø±Ø© Ø£ÙŠ ØªØ®Ø²ÙŠÙ† Ù‚Ø¯ÙŠÙ… (Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„ÙƒØ¨ÙŠØ± Ø£Ùˆ Ù…ÙØ§ØªÙŠØ­ room_pro_tex_*)
    async function migrateLegacy(){
      const toMove = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k && k.startsWith('room_pro_tex_')) toMove.push(k);
      }
      for (const k of toMove){
        const val = localStorage.getItem(k);
        if (val) {
          const key = k.replace('room_pro_tex_','');
          try { await saveTexture(key, val); } catch(e){ console.warn('Ù‡Ø¬Ø±Ø© ÙØ´Ù„Øª:', key, e); }
        }
        localStorage.removeItem(k);
      }
      const legacy = localStorage.getItem('room_config_pro');
      if (legacy){
        try {
          const data = JSON.parse(legacy);
          const tex = data.tex || {};
          for (const k of KEYS){ if (tex[k]){ try { await saveTexture(k, tex[k]); } catch(e){} } }
        } catch(e){ console.warn('Ù‡Ø¬Ø±Ø© Ø§Ù„Ù…ÙØªØ§Ø­ Ø§Ù„Ù‚Ø¯ÙŠÙ… ÙØ´Ù„Øª:', e); }
        localStorage.removeItem('room_config_pro');
      }
    }

    // ============ Ø­ÙØ¸/ØªØ­Ù…ÙŠÙ„ (Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ÙÙ‚Ø· ÙÙŠ LS) ============
    function saveState(){
      try {
        const dims = { L: ROOM.length, W: ROOM.width, H: ROOM.height };
        localStorage.setItem(lsKey('dims'), JSON.stringify(dims));
      } catch(e){ console.warn('âš ï¸ ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯:', e); }
    }

    async function loadState(){
      try {
        const raw = localStorage.getItem(lsKey('dims'));
        if (raw){
          const d = JSON.parse(raw);
          ROOM.length = parseFloat(d.L) || ROOM.length;
          ROOM.width  = parseFloat(d.W) || ROOM.width;
          ROOM.height = parseFloat(d.H) || ROOM.height;
        }
      } catch {}

      // Ø¬Ù„Ø¨ ÙƒÙ„ Ø§Ù„ØµÙˆØ± Ù…Ù† IndexedDB
      await Promise.all(KEYS.map(async k=>{
        const url = await getTextureURL(k);
        ROOM.textures[k] = url;
      }));

      // Ù…Ø²Ø§Ù…Ù†Ø© ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø­Ù‚ÙˆÙ„ ÙˆØ§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø§Øª
      document.getElementById('room-length').value = ROOM.length;
      document.getElementById('room-width').value  = ROOM.width;
      document.getElementById('room-height').value = ROOM.height;
      KEYS.forEach(k=>{
        const p = document.getElementById('preview-'+k);
        if (p) p.innerHTML = ROOM.textures[k] ? '<img src="'+ROOM.textures[k]+'">' : '';
      });

      return true;
    }

    // ============ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¹Ø±Ø¶ ============
    function setViewerSize(){
      const header = document.querySelector('header').offsetHeight;
      const toolbar = document.getElementById('toolbar').offsetHeight;
      const h = Math.max(280, window.innerHeight - header - toolbar);
      const wrap = document.getElementById('viewer-wrap');
      wrap.style.height = h + 'px';
      if (renderer) {
        renderer.setSize(wrap.clientWidth, wrap.clientHeight, false);
        camera.aspect = wrap.clientWidth / wrap.clientHeight;
        camera.updateProjectionMatrix();
      }
    }

    function initThree(){
      const canvas = document.getElementById('canvas3d');
      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:'high-performance' });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      if ('SRGBColorSpace' in THREE) renderer.outputColorSpace = THREE.SRGBColorSpace;

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xEAEFF7);

      camera = new THREE.PerspectiveCamera(70, 16/9, 0.1, 200);
      const amb = new THREE.AmbientLight(0xffffff, 0.70);
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); dir.position.set(5, 6, 4);
      scene.add(amb, dir);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false; controls.maxPolarAngle = Math.PI * 0.9; controls.minDistance = 0.4;

      window.addEventListener('resize', setViewerSize);
      setViewerSize();
      animate();
    }
    function animate(){ requestAnimationFrame(animate); controls && controls.update(); renderer.render(scene, camera); }

    // ============ ØªØ­Ù…ÙŠÙ„ Ø®Ø§Ù…Ø§Øª ============
    function loadTexture(url){
      return new Promise((resolve)=>{
        if (!url) return resolve(null);
        textureLoader.load(url, (tex)=>{
          if ('SRGBColorSpace' in THREE) tex.colorSpace = THREE.SRGBColorSpace;
          tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
          try { const aniso = renderer.capabilities.getMaxAnisotropy?.() || 0; if (aniso) tex.anisotropy = aniso; } catch {}
          resolve(tex);
        }, undefined, ()=>resolve(null));
      });
    }

    async function buildRoom(){
      const L = parseFloat(ROOM.length), W = parseFloat(ROOM.width), H = parseFloat(ROOM.height);

      scene.remove(sceneGroup);
      disposeGroup(sceneGroup);
      sceneGroup = new THREE.Group();

      const tex = {};
      for (const k of KEYS) tex[k] = await loadTexture(ROOM.textures[k]);

      const wallDefs = [
        { name:'Front_Wall', size:[L,H], pos:[0,0,-W/2], rot:[0, 0, 0],        key:'front'   },
        { name:'Back_Wall',  size:[L,H], pos:[0,0, W/2], rot:[0, Math.PI, 0],  key:'back'    },
        { name:'Right_Wall', size:[W,H], pos:[L/2,0, 0], rot:[0,-Math.PI/2,0], key:'right'   },
        { name:'Left_Wall',  size:[W,H], pos:[-L/2,0,0], rot:[0, Math.PI/2,0], key:'left'    },
        { name:'Floor',      size:[L,W], pos:[0,-H/2,0], rot:[-Math.PI/2,0,0], key:'floor'   },
        { name:'Ceiling',    size:[L,W], pos:[0, H/2,0], rot:[ Math.PI/2,0,0], key:'ceiling' }
      ];

      for (const w of wallDefs){
        const map = tex[w.key];
        const material = new THREE.MeshStandardMaterial({
          map, side: THREE.DoubleSide,
          color: map ? 0xffffff : (w.key==='floor'?DEFAULTS.floor:(w.key==='ceiling'?DEFAULTS.ceiling:DEFAULTS.wall))
        });
        const mesh = new THREE.Mesh(new THREE.PlaneGeometry(...w.size), material);
        mesh.position.set(...w.pos); mesh.rotation.set(...w.rot);

        if (map && map.image && map.image.width && map.image.height){
          const wallRatio = w.size[0] / w.size[1];
          const imgRatio  = map.image.width / map.image.height;
          if (imgRatio > wallRatio) map.repeat.set(wallRatio / imgRatio, 1);
          else map.repeat.set(1, imgRatio / wallRatio);
          map.offset.set((1 - map.repeat.x) / 2, (1 - map.repeat.y) / 2);
          map.needsUpdate = true;
        }
        sceneGroup.add(mesh);
      }

      camera.position.set(0, DEFAULTS.camEye - H/2, Math.max(L, W) * 0.95);
      controls.target.set(0, DEFAULTS.camEye - H/2, 0);
      controls.update();

      scene.add(sceneGroup);
      document.getElementById('exportGLB').disabled = sceneGroup.children.length === 0;
      saveState(); // ÙŠØ­ÙØ¸ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ÙÙ‚Ø· ÙÙŠ LS
    }

    function disposeGroup(group){
      group.traverse((obj)=>{
        if (obj.isMesh){
          obj.geometry?.dispose?.();
          if (Array.isArray(obj.material)){
            obj.material.forEach(m=>{ m.map?.dispose?.(); m.dispose?.(); });
          } else { obj.material?.map?.dispose?.(); obj.material?.dispose?.(); }
        }
      });
    }

    // ============ Ø£Ø¯Ø§Ø© Ø§Ù„Ù‚Øµ ============
    const cropTool   = document.getElementById('crop-tool');
    const cropCanvas = document.getElementById('crop-canvas');
    const ctx        = cropCanvas.getContext('2d');
    let img = new Image(), cropWallKey = null;

    let zoom=1, minZoom=0.1, maxZoom=6, angle=0, panX=0, panY=0;
    let draggingImage=false, lastX=0, lastY=0;

    let sel = { x:50, y:50, w:200, h:120 };
    const HANDLE = 8;
    let dragMode = null;
    function handles(){ return [
      {k:'nw', x:sel.x, y:sel.y}, {k:'ne', x:sel.x+sel.w, y:sel.y},
      {k:'sw', x:sel.x, y:sel.y+sel.h}, {k:'se', x:sel.x+sel.w, y:sel.y+sel.h},
      {k:'n', x:sel.x+sel.w/2, y:sel.y}, {k:'s', x:sel.x+sel.w/2, y:sel.y+sel.h},
      {k:'w', x:sel.x, y:sel.y+sel.h/2}, {k:'e', x:sel.x+sel.w, y:sel.y+sel.h/2},
    ];}
    function hitHandle(mx,my){
      const hs = handles();
      for (const h of hs){ if (Math.abs(mx-h.x)<=HANDLE && Math.abs(my-h.y)<=HANDLE) return h.k; }
      if (mx>=sel.x && mx<=sel.x+sel.w && my>=sel.y && my<=sel.y+sel.h) return 'move';
      return null;
    }

    function openCropUI(dataURL, wallKey){
      cropWallKey = wallKey;
      img = new Image();
      img.onload = ()=>{
        const maxW = Math.min(1800, window.innerWidth*0.9);
        const maxH = Math.min(1000, window.innerHeight*0.66);
        let cw = img.width, ch = img.height;
        const scale = Math.min(maxW/cw, maxH/ch, 1);
        cw = Math.floor(cw*scale); ch = Math.floor(ch*scale);
        cropCanvas.width = cw; cropCanvas.height = ch;

        zoom=1; angle=0; panX=0; panY=0;
        sel = { x:cw*0.2, y:ch*0.2, w:cw*0.6, h:ch*0.6 };
        document.getElementById('rotate-range').value = 0;
        redraw();
      };
      img.src = dataURL;
      cropTool.style.display='flex';
      cropTool.setAttribute('aria-hidden','false');
    }

    function redraw(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,cropCanvas.width,cropCanvas.height);

      ctx.save();
      ctx.translate(cropCanvas.width/2 + panX, cropCanvas.height/2 + panY);
      ctx.rotate(angle);
      ctx.scale(zoom, zoom);
      ctx.drawImage(img, -img.width/2, -img.height/2);
      ctx.restore();

      ctx.save(); ctx.fillStyle='rgba(0,0,0,.35)';
      ctx.fillRect(0,0,cropCanvas.width, sel.y);
      ctx.fillRect(0, sel.y, sel.x, sel.h);
      ctx.fillRect(sel.x+sel.w, sel.y, cropCanvas.width-(sel.x+sel.w), sel.h);
      ctx.fillRect(0, sel.y+sel.h, cropCanvas.width, cropCanvas.height-(sel.y+sel.h));
      ctx.restore();

      ctx.save(); ctx.strokeStyle='#e11d48'; ctx.lineWidth=2; ctx.setLineDash([6,6]);
      ctx.strokeRect(sel.x, sel.y, sel.w, sel.h); ctx.restore();

      ctx.save(); ctx.fillStyle='#fff'; ctx.strokeStyle='#e11d48';
      for (const h of handles()){ ctx.beginPath(); ctx.rect(h.x-HANDLE, h.y-HANDLE, HANDLE*2, HANDLE*2); ctx.fill(); ctx.stroke(); }
      ctx.restore();
    }

    cropCanvas.addEventListener('mousedown', (e)=>{
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      lastX = mx; lastY = my;
      const mode = hitHandle(mx,my);
      if (mode){ dragMode = mode; return; }
      if (e.altKey || e.which===2){ draggingImage = true; return; }
      if (!(mx>=sel.x && mx<=sel.x+sel.w && my>=sel.y && my<=sel.y+sel.h)){
        sel = { x:mx, y:my, w:0, h:0 }; dragMode='se';
      } else { dragMode='move'; }
    });
    cropCanvas.addEventListener('mousemove', (e)=>{
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const dx = mx - lastX, dy = my - lastY;

      if (draggingImage){ panX += dx; panY += dy; lastX=mx; lastY=my; redraw(); return; }

      if (dragMode){
        if (dragMode==='move'){ sel.x += dx; sel.y += dy; }
        else {
          const left=sel.x, top=sel.y, right=sel.x+sel.w, bottom=sel.y+sel.h;
          let nleft=left, nright=right, ntop=top, nbottom=bottom;
          if (dragMode.includes('w')) nleft += dx;
          if (dragMode.includes('e')) nright += dx;
          if (dragMode.includes('n')) ntop += dy;
          if (dragMode.includes('s')) nbottom += dy;
          const minSize=10;
          if (nright-nleft>=minSize){ sel.x=nleft; sel.w=nright-nleft; }
          if (nbottom-ntop>=minSize){ sel.y=ntop; sel.h=nbottom-ntop; }
        }
        lastX=mx; lastY=my; redraw(); return;
      }

      const mode2 = hitHandle(mx,my);
      const map = {n:'ns-resize',s:'ns-resize',e:'ew-resize',w:'ew-resize',ne:'nesw-resize',sw:'nesw-resize',nw:'nwse-resize',se:'nwse-resize',move:'move'};
      cropCanvas.style.cursor = mode2 ? map[mode2] : (e.altKey ? 'grab' : 'crosshair');
    });
    window.addEventListener('mouseup', ()=>{ draggingImage=false; dragMode=null; });
    cropCanvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const f = (e.deltaY<0)?1.1:0.9;
      const nz = Math.max(minZoom, Math.min(maxZoom, zoom*f));
      if (nz===zoom) return;
      const r = cropCanvas.getBoundingClientRect();
      const mx = e.clientX - r.left, my = e.clientY - r.top;
      const wx = mx - cropCanvas.width/2 - panX;
      const wy = my - cropCanvas.height/2 - panY;
      panX -= wx*(nz/zoom - 1);
      panY -= wy*(nz/zoom - 1);
      zoom = nz;
      redraw();
    }, {passive:false});

    document.getElementById('zoom-in').addEventListener('click', ()=>{ zoom = Math.min(maxZoom, zoom*1.2); redraw(); });
    document.getElementById('zoom-out').addEventListener('click', ()=>{ zoom = Math.max(minZoom, zoom/1.2); redraw(); });
    document.getElementById('rotate-90').addEventListener('click', ()=>{ angle += Math.PI/2; if (angle>Math.PI*2) angle-=Math.PI*2; redraw(); document.getElementById('rotate-range').value = Math.round(angle*180/Math.PI); });
    document.getElementById('rotate-range').addEventListener('input', (e)=>{ angle = parseFloat(e.target.value)*Math.PI/180; redraw(); });
    document.getElementById('reset-view').addEventListener('click', ()=>{ zoom=1; angle=0; panX=0; panY=0; redraw(); document.getElementById('rotate-range').value = 0; });

    // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚Øµ â€” Ø§Ù„Ø­ÙØ¸ ÙÙŠ IndexedDB
    document.getElementById('crop-apply').addEventListener('click', async ()=>{
      const sx = sel.w<0 ? sel.x+sel.w : sel.x;
      const sy = sel.h<0 ? sel.y+sel.h : sel.y;
      const sw = Math.abs(sel.w), sh = Math.abs(sel.h);
      if (sw<2 || sh<2){ closeCrop(); return; }

      // Ø§Ø±Ø³Ù… Ø§Ù„ØµÙˆØ±Ø© (Ø¨Ø¯ÙˆÙ† Ù…Ù‚Ø§Ø¨Ø¶) Ø¥Ù„Ù‰ ÙƒØ§Ù†ÙØ³ Ù…Ø¤Ù‚Øª
      const temp = document.createElement('canvas');
      temp.width = cropCanvas.width; temp.height = cropCanvas.height;
      const tctx = temp.getContext('2d');
      tctx.save();
      tctx.translate(cropCanvas.width/2 + panX, cropCanvas.height/2 + panY);
      tctx.rotate(angle);
      tctx.scale(zoom, zoom);
      tctx.drawImage(img, -img.width/2, -img.height/2);
      tctx.restore();

      // Ø«Ù… Ù‚Øµ Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ù…Ø­Ø¯Ø¯
      const out = document.createElement('canvas');
      out.width = Math.max(1, Math.round(sw));
      out.height = Math.max(1, Math.round(sh));
      out.getContext('2d').drawImage(temp, sx, sy, sw, sh, 0, 0, out.width, out.height);

      const dataURL = out.toDataURL('image/png');

      await saveTexture(cropWallKey, dataURL); // -> IndexedDB + URL
      updatePreview(cropWallKey, ROOM.textures[cropWallKey]);
      closeCrop();
      await buildRoom();
      saveState(); // Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ ÙÙ‚Ø·
    });

    function closeCrop(){ cropTool.style.display='none'; cropTool.setAttribute('aria-hidden','true'); cropWallKey=null; }
    document.getElementById('crop-cancel').addEventListener('click', closeCrop);

    function updatePreview(key, url){
      const p = document.getElementById('preview-'+key);
      if (p) p.innerHTML = url ? '<img src="'+url+'">' : '';
    }

    // ============ Ø±Ø¨Ø· Ù…Ø¯Ø®Ù„Ø§Øª Ø§Ù„ØµÙˆØ± ============
    document.querySelectorAll('input[type="file"][data-wall]').forEach(input=>{
      input.addEventListener('change', (e)=>{
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = (ev)=>{
          const base64 = ev.target.result;
          const key = e.target.getAttribute('data-wall');
          openCropUI(base64, key);
          e.target.value='';
        };
        reader.readAsDataURL(f);
      });
    });

    // ============ Ø£Ø²Ø±Ø§Ø± Ø¹Ø§Ù…Ø© ============
    document.getElementById('update-room').addEventListener('click', ()=>{
      ROOM.length = parseFloat(document.getElementById('room-length').value) || ROOM.length;
      ROOM.width  = parseFloat(document.getElementById('room-width').value)  || ROOM.width;
      ROOM.height = parseFloat(document.getElementById('room-height').value) || ROOM.height;
      buildRoom();
    });

    document.getElementById('clear-saved').addEventListener('click', async ()=>{
      if (!confirm('Ù…Ø³Ø­ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„ØµÙˆØ± Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©ØŸ')) return;
      try {
        await idbClear();
      } catch(e){ console.warn('Ù…Ø³Ø­ IDB ÙØ´Ù„:', e); }
      localStorage.removeItem(lsKey('dims'));
      localStorage.removeItem('room_config_pro'); // Ù„Ùˆ Ø¨Ø§Ù‚ÙŠ
      // ØªÙ†Ø¸ÙŠÙ Ø£ÙŠ Ù…ÙØ§ØªÙŠØ­ Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ø§Ù„ØµØ¯ÙØ©
      const oldKeys = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k && k.startsWith('room_pro_tex_')) oldKeys.push(k);
      }
      oldKeys.forEach(k=>localStorage.removeItem(k));

      for (const k of KEYS) ROOM.textures[k] = null;
      KEYS.forEach(k=>updatePreview(k, null));
      buildRoom();
    });

    // ============ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© ============
    const fsBtn = document.getElementById('fullscreen-btn');
    const viewer = document.getElementById('viewer-wrap');
    function isFS(){ return !!document.fullscreenElement; }
    fsBtn.addEventListener('click', ()=>{ isFS() ? document.exitFullscreen() : viewer.requestFullscreen(); });
    document.addEventListener('fullscreenchange', ()=>{ fsBtn.textContent = isFS() ? 'âœ–' : 'â›¶'; setViewerSize(); });

    // ============ ØªØµØ¯ÙŠØ± / Ø§Ø³ØªÙŠØ±Ø§Ø¯ GLB ============
    document.getElementById('exportGLB').addEventListener('click', async ()=>{
      if (!sceneGroup || sceneGroup.children.length===0){ alert('Ø§Ø¨Ù†Ù Ø§Ù„ØºØ±ÙØ© Ø£ÙˆÙ„Ù‹Ø§'); return; }
      const exporter = new THREE.GLTFExporter();
      try {
        const glb = await new Promise((resolve,reject)=>{ exporter.parse(sceneGroup, resolve, { binary:true, embedImages:true }, reject); });
        const blob = new Blob([glb], {type:'model/gltf-binary'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob); a.download = 'Room.glb';
        document.body.appendChild(a); a.click();
        setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
      } catch(err){ console.error('ÙØ´Ù„ Ø§Ù„ØªØµØ¯ÙŠØ±:', err); alert('ÙØ´Ù„ Ø§Ù„ØªØµØ¯ÙŠØ± Ø¥Ù„Ù‰ GLB'); }
    });

    document.getElementById('importGLB').addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const url = URL.createObjectURL(file);
      const loader = new THREE.GLTFLoader();
      loader.load(url, (gltf)=>{
        scene.remove(sceneGroup);
        disposeGroup(sceneGroup);
        sceneGroup = new THREE.Group();
        const imported = gltf.scene;
        sceneGroup.add(imported);
        scene.add(sceneGroup);
        const box = new THREE.Box3().setFromObject(imported);
        const center = new THREE.Vector3(); box.getCenter(center);
        controls.target.copy(center); controls.update();
        document.getElementById('exportGLB').disabled = false;
        URL.revokeObjectURL(url);
        alert('ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„.');
      }, undefined, (err)=>{ console.error('GLB ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„:', err); alert('ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ GLB'); });
    });

    // ============ ØªØ´ØºÙŠÙ„ ============
    window.addEventListener('DOMContentLoaded', async ()=>{
      initThree();
      // Ù‡Ø¬Ø±Ø© Ø£ÙŠ ØªØ®Ø²ÙŠÙ† Ù‚Ø¯ÙŠÙ… (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©)
      await migrateLegacy();
      await loadState();     // ÙŠØ¬Ù„Ø¨ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ + URLs Ù…Ù† IDB
      await buildRoom();     // ÙŠØ¨Ù†ÙŠ ÙÙˆØ±Ù‹Ø§
    });
  </script>
</body>
</html>
